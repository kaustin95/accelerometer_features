# -*- coding: utf-8 -*-
"""FalsePosCalcs.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13L-KDpKPZINkAXkT_igo4HtwqmMdG0Dh
"""
import pandas as pd
import numpy as np
from os import name
from scipy import signal
from scipy.integrate import trapz
from scipy.signal import welch
from scipy.stats import skew


# flatten dict
def flatten_dict(d, parent_key='', sep='_'):
    flattened_dict = {}
    for k, v in d.items():
        new_key = f"{parent_key}{sep}{k}" if parent_key else k
        if isinstance(v, dict):
            flattened_dict.update(flatten_dict(v, new_key, sep=sep))
        else:
            flattened_dict[new_key] = v
    return flattened_dict

def FalsePosVariableCalc(dataframe):

    # Define the column indices for each axis
    column_indices = {
        'linx': 16, 'liny': 17, 'linz': 18,
        'velx': 20, 'vely': 21, 'velz': 22,
        'angx': 24, 'angy': 25, 'angz': 26,
    }

    # Dictionary to store lists for each axis
    data_dict = {key + '_list': [] for key in column_indices.keys()}

    # Extract accelerometer data for each trial
    for _, row in dataframe.iterrows():
        for key, col_index in column_indices.items():
            cell_value = row[col_index]

            if isinstance(cell_value, str):
                # If it's a string, use np.fromstring
                data = np.fromstring(cell_value, sep=',')
            elif isinstance(cell_value, float):
                # If it's a float, convert to string and use np.fromstring
                data = np.fromstring(str(cell_value), sep=',')
            else:
                # Handle other cases if necessary
                data = np.array([])  # or other appropriate handling

            data_dict[key + '_list'].append(data)

    # Calculate resultant acceleration for each axis (linear, velocity, and angular)
    data_dict['linres_list'] = []
    data_dict['velres_list'] = []
    data_dict['angres_list'] = []
    data_dict['ratio_list'] = []

    for i in range(len(data_dict['linx_list'])):
        lin_resultant = np.sqrt(data_dict['linx_list'][i]**2 + data_dict['liny_list'][i]**2 + data_dict['linz_list'][i]**2)
        vel_resultant = np.sqrt(data_dict['velx_list'][i]**2 + data_dict['vely_list'][i]**2 + data_dict['velz_list'][i]**2)
        ang_resultant = np.sqrt(data_dict['angx_list'][i]**2 + data_dict['angy_list'][i]**2 + data_dict['angz_list'][i]**2)

        data_dict['linres_list'].append(lin_resultant)
        data_dict['velres_list'].append(vel_resultant)
        data_dict['angres_list'].append(ang_resultant)

        ratio = data_dict['linres_list'][i] / data_dict['angres_list'][i]
        data_dict['ratio_list'].append(ratio)


    # Statistical Summaries
    # Dictionary to store calculated statistics for each axis

    # Initialize an empty dictionary for each statistics type
    stats_dict = {key: {} for key in ['mean', 'min', 'max', 'std', 'variance', 'range']}

    # Calculate statistics for each trial for all variables
    for variable, values in data_dict.items():
        # Calculate statistics for each trial
        mean_values = np.mean(values, axis=1)
        min_values = np.min(values, axis=1)
        max_values = np.max(values, axis=1)
        std_values = np.std(values, axis=1)
        var_values = np.var(values, axis=1)
        range_values = np.ptp(values, axis=1)

        # Extend the lists of statistics in the stats_dict
        stats_dict['mean'].setdefault(variable, []).extend(mean_values.tolist())
        stats_dict['min'].setdefault(variable, []).extend(min_values.tolist())
        stats_dict['max'].setdefault(variable, []).extend(max_values.tolist())
        stats_dict['std'].setdefault(variable, []).extend(std_values.tolist())
        stats_dict['variance'].setdefault(variable, []).extend(var_values.tolist())
        stats_dict['range'].setdefault(variable, []).extend(range_values.tolist())

    # Pulse Duration Variables
    # Dictionary to store results
    pulse_dict = {
        'ImpactStartLin': [],
        'ImpactEndLin': [],
        'LinearPulseWidth': [],
        'LinearAUC': [],
        'ImpactStartAng': [],
        'ImpactEndAng': [],
        'AngularPulseWidth': [],
        'AngularAUC': []
    }

    # Linear
    for i, trial in enumerate(data_dict['linres_list']):
        # Identify the location of the first value greater than LinRes_Mean
        impact_start_lin = next((index for index, value in enumerate(trial) if value > stats_dict['mean']['linres_list'][i]), None)
        # Identify the location of the first value after ImpactStartLin that goes below LinRes_Mean
        if impact_start_lin is not None:
            impact_end_lin = next((index for index, value in enumerate(trial[impact_start_lin:], start=impact_start_lin) if value < stats_dict['mean']['linres_list'][i]), None)
            # If the trial does not go back below the mean, use the location of the minimum value after impact_start_lin
            if impact_end_lin is None:
                min_after_impact = np.argmin(trial[impact_start_lin:]) + impact_start_lin
                impact_end_lin = min_after_impact
        else:
            impact_end_lin = None

        # Calculate linearpulsewidth
        linearpulsewidth = impact_end_lin - impact_start_lin if impact_end_lin is not None else None

        # Calculate linearauc
        if impact_start_lin is not None and impact_end_lin is not None:
            linear_auc = trapz(trial[impact_start_lin:impact_end_lin], dx=1.0/1000)  # Assuming time is at 1000Hz
        else:
            linear_auc = None

        # Append results to the dictionary
        pulse_dict['ImpactStartLin'].append(impact_start_lin)
        pulse_dict['ImpactEndLin'].append(impact_end_lin)
        pulse_dict['LinearPulseWidth'].append(linearpulsewidth)
        pulse_dict['LinearAUC'].append(linear_auc)

    # Angular
    for i, trial in enumerate(data_dict['angres_list']):
        # Identify the location of the first value greater than AngRes_Mean
        impact_start_ang = next((index for index, value in enumerate(trial) if value > stats_dict['mean']['angres_list'][i]), None)
        # Identify the location of the first value after ImpactStartAng that goes below AngRes_Mean
        if impact_start_ang is not None:
            impact_end_ang = next((index for index, value in enumerate(trial[impact_start_ang:], start=impact_start_ang) if value < stats_dict['mean']['angres_list'][i]), None)
            # If the trial does not go back below the mean, use the location of the minimum value after impact_start_ang
            if impact_end_ang is None:
                min_after_impact = np.argmin(trial[impact_start_ang:]) + impact_start_ang
                impact_end_ang = min_after_impact
        else:
            impact_end_ang = None

        # calculate angularpulsewidth
        angularpulsewidth = impact_end_ang - impact_start_ang if impact_end_ang is not None else None

        # Calculate angularauc
        if impact_start_ang is not None and impact_end_ang is not None:
            angular_auc = trapz(trial[impact_start_ang:impact_end_ang], dx=1.0/1000)  # Assuming time is at 1000Hz
        else:
            angular_auc = None

        pulse_dict['ImpactStartAng'].append(impact_start_ang)
        pulse_dict['ImpactEndAng'].append(impact_end_ang)
        pulse_dict['AngularPulseWidth'].append(angularpulsewidth)
        pulse_dict['AngularAUC'].append(angular_auc)

    # PSD Variables
    # Dictionary to store results
    psd_dict = {
        'PSDlin': [], 'PSDang': [], 'PSD_Lin_20HzBin': [], 'PSD_Ang_20HzBin': [], 'PSD_Lin_40HzBin': [],
        'PSD_Ang_40HzBin': [], 'PSD_Lin_60HzBin': [], 'PSD_Ang_60HzBin': [], 'PSD_Lin_80HzBin': [], 'PSD_Ang_80HzBin': [],
        'PSD_Lin_100HzBin': [], 'PSD_Ang_100HzBin': [], 'PSD_Lin_120HzBin': [], 'PSD_Ang_120HzBin': [],
        'PSD_Lin_140HzBin': [], 'PSD_Ang_140HzBin': [], 'PSD_Lin_160HzBin': [], 'PSD_Ang_160HzBin': [],
        'PSD_Lin_180HzBin': [], 'PSD_Ang_180HzBin': [], 'PSD_Lin_200HzBin': [], 'PSD_Ang_200HzBin': [],
        'PSD_Lin_250HzBin': [], 'PSD_Ang_250HzBin': [],
        'PSD_Lin_300HzBin': [], 'PSD_Ang_300HzBin': [], 'PSD_Lin_350HzBin': [], 'PSD_Ang_350HzBin': [],
        'PSD_Lin_Skew': [], 'PSD_Ang_Skew': []
    }

    # Frequency bins
    frequency_bins = [20, 40, 60, 80, 100, 120, 140, 160, 180, 200, 250, 300, 350, 400]  # Adjusted to include '200+Hz'

    # Linear
    for i, trial in enumerate(data_dict['linres_list']):
        # Linear PSD calculation
        f_lin, psd_lin = welch(trial - np.mean(trial), fs=1000, nperseg=500)

        # Normalize PSD
        psd_lin = psd_lin / np.sum(psd_lin)

        # Append results to the dictionary
        psd_dict['PSDlin'].append(psd_lin)

        # Calculate area under PSD curve for each frequency bin
        for j in range(len(frequency_bins) - 1):
            start_freq = frequency_bins[j]
            end_freq = frequency_bins[j + 1]
            indices = np.where((f_lin >= start_freq) & (f_lin < end_freq))[0]
            area_bin = np.trapz(psd_lin[indices], f_lin[indices])
            psd_dict[f'PSD_Lin_{start_freq}HzBin'].append(area_bin)

        # Calculate skewness of the PSD
        skewness_lin = skew(psd_lin)
        psd_dict['PSD_Lin_Skew'].append(skewness_lin)

    # Angular
    for i, trial in enumerate(data_dict['angres_list']):
        # Angular PSD calculation
        f_ang, psd_ang = welch(trial - np.mean(trial), fs=1000, nperseg=500)

        # Normalize PSD
        psd_ang = psd_ang / np.sum(psd_ang)

        # Append results to the dictionary
        psd_dict['PSDang'].append(psd_ang)

        # Calculate area under PSD curve for each frequency bin
        for j in range(len(frequency_bins) - 1):
            start_freq = frequency_bins[j]
            end_freq = frequency_bins[j + 1]
            indices = np.where((f_ang >= start_freq) & (f_ang < end_freq))[0]
            area_bin = np.trapz(psd_ang[indices], f_ang[indices])
            psd_dict[f'PSD_Ang_{start_freq}HzBin'].append(area_bin)

        # Calculate skewness of the PSD
        skewness_ang = skew(psd_ang)
        psd_dict['PSD_Ang_Skew'].append(skewness_ang)

    # Remove whole psd lin and ang from dict
    # Create a new dictionary without 'PSDlin' and 'PSDang'
    psd_dict2 = {key: value for key, value in psd_dict.items() if key not in ['PSDlin', 'PSDang']}

    # Flatten dicts
    flat_stats_dict = flatten_dict(stats_dict)
    flat_pulse_dict = flatten_dict(pulse_dict)

    # Add dicts together
    output = {}
    output.update(flat_stats_dict)
    output.update(flat_pulse_dict)
    output.update(psd_dict2)

    # Column Names
    name_list = list(output.keys())
    name_list = [name.replace('_list', '') for name in name_list]

    # Convert to dataframe
    dataframe = pd.DataFrame.from_dict(output, orient='index').T
    dataframe.columns = name_list

    return dataframe